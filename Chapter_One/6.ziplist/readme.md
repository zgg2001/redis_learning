# 压缩列表
## 一、总结
1. 压缩列表被用作列表键和哈希键的底层实现之一。
* 列表键中只有少量列表项，并且每个列表项是小整数值或长度较短字符串时，redis使用压缩列表用于列表键底层实现。
* 哈希键只包含少量键值对，并且每个键值对的键和值是小整数或长度较短字符串时，redis使用压缩列表用于哈希键底层实现。
2. 压缩列表是一种为节约内存而开发的顺序型数据结构。
3. 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
4. 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发**连锁更新**操作，但是最恶劣情况出现的概率不大，整体的平均时间复杂度还是O(N)。我感觉这个**连锁更新**操作也是压缩列表中一个蛮重要的点，需要留意一下。
5. 这个结构我感觉就是一个有特殊标记的连续数组结构，所以没有太过深入的了解和记录。

&emsp;
## 二、压缩列表的数据结构
### 1. 压缩列表
```cpp
/* 
空白 ziplist 示例图

area        |<---- ziplist header ---->|<-- end -->|

size          4 bytes   4 bytes 2 bytes  1 byte
            +---------+--------+-------+-----------+
component   | zlbytes | zltail | zllen | zlend     |
            |         |        |       |           |
value       |  1011   |  1010  |   0   | 1111 1111 |
            +---------+--------+-------+-----------+
                                       ^
                                       |
                               ZIPLIST_ENTRY_HEAD
                                       &
address                        ZIPLIST_ENTRY_TAIL
                                       &
                               ZIPLIST_ENTRY_END

非空 ziplist 示例图

area        |<---- ziplist header ---->|<----------- entries ------------->|<-end->|

size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte
            +---------+--------+-------+--------+--------+--------+--------+-------+
component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
            +---------+--------+-------+--------+--------+--------+--------+-------+
                                       ^                          ^        ^
address                                |                          |        |
                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END
                                                                  |
                                                        ZIPLIST_ENTRY_TAIL
*/
```
&emsp;&emsp;压缩列表的整体数据结构如上，摘自huangz大佬的源码注释。<br>
&emsp;&emsp;简单来说，压缩列表就是一个有特殊标记的连续数组。里面的组成部分具体功能如下：
* 数组头块区域`zlbytes`记录了整个压缩列表的长度。
* 第二块区域`zltail`则是一个偏移量，记录了表尾节点到压缩列表起始地址的偏移量。
* 第三块区域`zllen`记录了数据节点的个数。
* 后续即为`entryX`即为数据节点，储存数据。
* 最后的`zlend`为固定特殊值`OxFF`，用于标记尾端，可以理解为压缩列表的`\0`。

### 2. 压缩列表节点
```cpp
/*
size                1/5 bytes       1/2/5 bytes   若干
            +-----------------------+----------+---------+
component   | previous_entry_length | encoding | content |
            +-----------------------+----------+---------+
*/
```
&emsp;&emsp;压缩列表节点的数据结构如上，主要是由三部分组成：前一节点长度、编码方式与内容。具体功能如下：
* 第一块内容`previous_entry_length`记录了上一个节点的长度，进行指针运算即可寻址上一个节点。所以可以根据压缩列表第二块区域`zltail`直接偏移至尾节点，再获取上一格节点的长度进行指针运算即可进行压缩列表遍历操作。
* 第二块内容`encoding`来标记`content`的数据类型是啥，大致分两类：数字和字节数组。多种编码代表数字的位类型或是字节数组的长度，还是蛮多种的，在这里就不做具体记录了(~~因为感觉后续会忘~~)，以后有需求的时候再仔细看一下编码类型。
* 第三块内容`content`就是实际的内容了，如果是字节数组的话`encoding`字段会记录数组的长度，否则就是存一个相关类型的数字。

&emsp;
## 三、连锁更新
&emsp;&emsp;上面大致说了一下压缩列表节点的数据结构，其中字段`previous_entry_length`的长度会根据上一个节点的长度变化。上一个节点的长度小于254字节时，这个字段的长度为1字节；当上一个节点的长度大于等于254时，这个字段的长度为五字节。<br>
&emsp;&emsp;这样的规则下，假设当有连续的、长度介于250字节到253字节之间的节点，称为e1到eN。如果此时在头部插入一个新的长度大于等于254字节的节点，则其成为e1的前置节点，此时e1的`previous_entry_length`字段长度由1字节扩容为5字节，所以e1的新长度变为介于254字节至257字节之间。而当e1变化后，e2的`previous_entry_length`字段也需扩容至5字节，e3到eN也同理。按照这个情况，会引起所谓的“连锁更新”。<br>
&emsp;&emsp;除了添加新结点以外，删除节点也可能会引发连锁更新。在最坏情况下，连锁更新会执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N方)。但是实际中连锁更新造成性能问题的概率还是很低的，主要还是因为条件比较苛刻。